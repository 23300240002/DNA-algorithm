代码总体上分为三个部分：预处理、动态规划切分 query、输出构造结果。
下面对各个部分进行说明：

1. 预处理 reference 中的子串
首先遍历 reference 的所有可能连续子串，并将每个子串与其在 reference 中首次出现的起始位置记录到一个哈希表（substring_map）中，同时标记该子串来自正链（bool 为 false）。
接下来，对 reference 计算它的互补翻转序列（调用函数），即将 reference 进行翻转后再做 A↔T、C↔G 的互补变换。
遍历互补翻转后的 reference_rc 的所有连续子串。当某个子串在哈希表中尚未出现时，则记录它对应在原始 reference 中的起始下标（通过计算转换公式：m - len - i，其中 m 为 reference 长度，len 为子串长度，i 为该子串在 reference_rc 中的起始下标）并设定标记为互补翻转（bool 为 true）。这样保证若在正链中没有出现，而在翻转链中出现，则使用翻转链匹配的结果，但输出时仍给出正链的位置。

2. 动态规划进行 query 分割
定义 dp 数组，其中 dp[i] 表示从 query 下标 i 到末尾的区域能被分解为几个合法子串的最小个数，初始值设为 n+1，dp[n] 设为 0（空串分割个数为 0）。
定义 trace 数组记录每个位置的转移信息，用于恢复切分方案，记录下一位置、在 reference 中匹配到的子串的起始位置以及是否为翻转匹配的标志。
从 query 的尾部倒序扫描：对于每个下标 i，从 i 开始逐步扩展形成子串 sub，若该子串在 substring_map 中存在，则查看用该子串匹配后剩余部分 dp[j+1] 的值，选择使 dp[i] 达到最小值（即整个 query 分割成尽可能少的单元，从而重复单元尽可能长）。同时记录子串在 reference 中的起始位置和其匹配类型（正链或互补翻转）。

3. 构造及输出结果
利用 trace 数组从 query 起始位置 0 不断恢复各个子串的匹配信息，每个子串对应一个重复单元，记录的信息包括：
在 reference 中匹配到的区间（[start, start + len - 1]）；
是否通过翻转匹配（inversion）。
将这些匹配信息依次存入结果容器中，并通过标准输出打印，每一行输出一个匹配单元的【起始位置区间】和 inversion 标识。

4. 综上
代码通过预处理建立了 reference 中所有连续子串及其正向和互补翻转对应在正链的起始位置，再利用动态规划在 query 中寻找一种最优的连续分割方案，使得每个分段都能在 reference 中查找到对应匹配（同时满足翻转判断）。通过这种分割，尽可能保证每个重复单元较长（因为分段数量最小），从而实现题目的要求。
